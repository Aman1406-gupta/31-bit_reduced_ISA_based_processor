library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

use work.ISA_Pkg.all;

entity tb_Reduced_ISA_Processor is
end tb_Reduced_ISA_Processor;

architecture sim of tb_Reduced_ISA_Processor is
    -- Clock and reset
    signal clk   : std_logic := '0';
    signal reset : std_logic := '0';

    -- Register file outputs
    signal r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, r10, r11, r12, r13, r14, r15 : std_logic_vector(31 downto 0);
    signal r16, r17, r18, r19, r20, r21, r22, r23, r24, r25, r26, r27, r28, r29, r30, r31 : std_logic_vector(31 downto 0);

    -- Program memory
    signal program_mem : mem_array := (
    -- Sample program: Reduced Instruction Set
    --I-Type Instructions
    0  => "000001" & "00010" & "00011" & "0000000000000010",                    -- ADDI  r3 = r2 + 2
    1  => "000010" & "00100" & "00101" & "0000000000000010",                    -- ADDIU r5 = r4 + 2
    2  => "000011" & "00110" & "00111" & "0000000000001010",                    -- ANDI  r7 = r6 & 10   //r7 is initially 4 for other test cases
    3  => "000100" & "01000" & "01001" & "0000000000001010",                    -- ORI   r9 = r8 | 10
    4  => "000101" & "01010" & "01011" & "0000000000001010",                    -- XORI  r11 = r10 ^ 10
    5  => "000110" & "01100" & "01101" & "0000000000001010",                    -- LUI   r13 = 10 (load upper immediate)
    6  => "000111" & "00000" & "01111" & "0000000000000010",                    -- LW    r15 = MEM[r0 + 2]
    7  => "001000" & "10000" & "01101" & "0000000000000100",                    -- SW    MEM[r16 + 4] = r13
    8  => "001001" & "10010" & "10011" & "0000000000000001",                    -- BEQ   if r18 == r19 branch +1
    9  => "001010" & "10100" & "00101" & "0000000000000001",                    -- BNE   if r20 != r5 branch +1
    10 => "001111" & "10110" & "10111" & "0000000000000001",                    -- SLTI  r23 = (r22 < 1) ? 1 : 0
    11 => "010000" & "11000" & "11001" & "0000000000000001",                    -- SLTIU r25 = (r24 < 1) unsigned

    --J-Type Instructions
    12 => "010001" & "00000000000000000000000001",                              -- JUMP  to address 1

    -- R-Type Instructions (Grouped separately)
    13 => "000000" & "00010" & "00011" & "00100" & "00000" & "000000",           -- ADD   r4 = r2 + r3
    14 => "000000" & "00010" & "00011" & "00100" & "00000" & "000001",           -- ADDU  r4 = r2 + r3
    15 => "000000" & "00010" & "00011" & "00100" & "00000" & "000010",           -- SUB   r4 = r2 - r3
    16 => "000000" & "00010" & "00011" & "00100" & "00000" & "000011",           -- SUBU  r4 = r2 - r3 (unsigned)
    17 => "000000" & "00010" & "00011" & "00100" & "00000" & "000100",           -- AND   r4 = r2 & r3
    18 => "000000" & "00010" & "00011" & "00100" & "00000" & "000101",           -- OR    r4 = r2 | r3
    19 => "000000" & "00010" & "00011" & "00100" & "00000" & "000110",           -- XOR   r4 = r2 ^ r3
    20 => "000000" & "00010" & "00011" & "00100" & "00000" & "000111",           -- NOR   r4 = ~(r2 | r3)
    21 => "000000" & "00000" & "00011" & "00100" & "00110" & "001000",           -- SLL   r4 = r3 << 6
    22 => "000000" & "00000" & "00011" & "00100" & "00110" & "001001",           -- SRL   r4 = r3 >> 6 (logical)
    23 => "000000" & "00000" & "00011" & "00100" & "00110" & "001010",           -- SRA   r4 = r3 >> 6 (arithmetic)
    24 => "000000" & "00000" & "00011" & "00100" & "00110" & "001011",           -- ROR   r4 = rotate right r3 by 6
    25 => "000000" & "00010" & "00011" & "00100" & "00000" & "001100",           -- SLT   r4 = (r2 < r3) ? 1 : 0
    26 => "000000" & "00010" & "00011" & "00100" & "00000" & "001101",           -- SLTU  r4 = (r2 < r3) unsigned
        
        -- Sample program: For Hazard Control and Branch/Jump
--          0 =>  "000111" & "00000" & "00001" & "0000000000000010",            -- lw   r1, 2(r0)   //Mem(2) = 0
--          1 =>  "000000" & "00000" & "00001" & "00111" & "00000" & "000101",  -- or   r7, r0, r1
--          2 =>  "000000" & "00001" & "00001" & "00010" & "00000" & "000000",  -- add  r2, r1, r1
--          3 =>  "000000" & "00010" & "00001" & "00011" & "00000" & "000010",  -- sub  r3, r2, r1
--          4 =>  "000000" & "00011" & "00001" & "00100" & "00000" & "000100",  -- and  r4, r3, r1
--          5 =>  "000000" & "00100" & "00001" & "00101" & "00000" & "000101",  -- or   r5, r4, r1
--          6 =>  "001000" & "00000" & "00101" & "0000000000000100",            -- sw   r5, 4(r0)
--          7 =>  "000000" & "00101" & "00101" & "00110" & "00000" & "000000",  -- add  r6, r5, r5  
--          8  => "001001" & "00010" & "00110" & "0000000000000011",            -- BEQ  r2 == r6
--          9  => "001010" & "00010" & "00101" & "0000000000000100",            -- BNE  r2 != r5  
--          10 => "000101" & "01011" & "00001" & "0000000000001010",            -- XORI r1, r13,10
--          11 => "000110" & "01011" & "00001" & "0000000000001010",            -- LUI  r1, r13,10
--          12 => "000000" & "00110" & "00100" & "00110" & "00000" & "001101",  -- SLTU r6,r3,r4  
--          13 => "010001" & "00000000000000000000001001",                      -- JUMP to 9th inst.
--          14 => "000000" & "00000" & "00011" & "00100" & "10000" & "001011",  -- ROR  r4,r3,sa
    
        -- Sample program: For Loop
--        0 => "000111" & "00000" & "00001" & "0000000000000000",               -- lw  r1, 0(r0) ;    // Mem(0) = 0 
--        1 => "000111" & "00000" & "00010" & "0000000000000100",               -- lw  r2, 4(r0) ; 16 // Mem(1) = 16
--        2 => "001001" & "00001" & "00010" & "0000000000000100",               -- beq r1, r2, +5
--        3 => "000000" & "00000" & "00000" & "00000" & "00000" & "000000",     -- nop (sll r0, r0, 0)
--        4 => "000000" & "00001" & "00111" & "00001" & "00000" & "000000",     -- add r1, r1, r7
--        5 => "010001" & "00000000000000000000000010",                         -- j to addr 2 (loop start)
--        6 => "000000" & "00000" & "00000" & "00000" & "00000" & "000000",     -- padding nop
--        7 => "111111" & "00000" & "00000" & "00000" & "00000" & "000000",     -- Exit (as Op code is not part of Reduced ISA)
        others => (others => '0')
    );

begin
    -- Clock generation
    clk_process: process
    begin
        while now < 5000 ns loop
            clk <= '1'; wait for 5 ns;
            clk <= '0'; wait for 5 ns;
        end loop;
        wait;
    end process;

    -- Reset logic
    stim_proc: process
    begin
        reset <= '1';
        wait for 20 ns;
        reset <= '0';
        wait;
    end process;
    
    -- Instantiate the processor
    DUT: entity work.Reduced_ISA_Processor
        port map (
            clk     => clk,
            reset   => reset,
            program => program_mem,
            r0 => r0, r1 => r1, r2 => r2, r3 => r3, r4 => r4, r5 => r5, r6 => r6, r7 => r7,
            r8 => r8, r9 => r9, r10 => r10, r11 => r11, r12 => r12, r13 => r13, r14 => r14, r15 => r15,
            r16 => r16, r17 => r17, r18 => r18, r19 => r19, r20 => r20, r21 => r21, r22 => r22, r23 => r23,
            r24 => r24, r25 => r25, r26 => r26, r27 => r27, r28 => r28, r29 => r29, r30 => r30, r31 => r31
        );
end sim;